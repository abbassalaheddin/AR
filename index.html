<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <script>
      // ============================================
      // KALMAN FILTER IMPLEMENTATION
      // ============================================
      class KalmanFilter {
        constructor(processNoise = 0.01, measurementNoise = 0.1) {
          this.Q = processNoise;  // Process noise
          this.R = measurementNoise;  // Measurement noise
          this.P = 1;  // Estimation error
          this.x = 0;  // Current estimate
          this.K = 0;  // Kalman gain
        }

        filter(measurement) {
          // Prediction
          this.P = this.P + this.Q;
          
          // Update
          this.K = this.P / (this.P + this.R);
          this.x = this.x + this.K * (measurement - this.x);
          this.P = (1 - this.K) * this.P;
          
          return this.x;
        }

        reset(value) {
          this.x = value;
          this.P = 1;
        }
      }

      // ============================================
      // VECTOR KALMAN FILTER (for 3D positions)
      // ============================================
      class VectorKalmanFilter {
        constructor(processNoise = 0.01, measurementNoise = 0.1) {
          this.filters = {
            x: new KalmanFilter(processNoise, measurementNoise),
            y: new KalmanFilter(processNoise, measurementNoise),
            z: new KalmanFilter(processNoise, measurementNoise)
          };
        }

        filter(vector) {
          return {
            x: this.filters.x.filter(vector.x),
            y: this.filters.y.filter(vector.y),
            z: this.filters.z.filter(vector.z)
          };
        }

        reset(vector) {
          this.filters.x.reset(vector.x);
          this.filters.y.reset(vector.y);
          this.filters.z.reset(vector.z);
        }
      }

      // ============================================
      // IMU DATA READER
      // ============================================
      class IMUReader {
        constructor() {
          this.acceleration = { x: 0, y: 0, z: 0 };
          this.rotation = { alpha: 0, beta: 0, gamma: 0 };
          this.hasPermission = false;
          this.initialized = false;
        }

        async init() {
          if (this.initialized) return true;

          // Request permission for iOS 13+
          if (typeof DeviceMotionEvent !== 'undefined' && 
              typeof DeviceMotionEvent.requestPermission === 'function') {
            try {
              const permission = await DeviceMotionEvent.requestPermission();
              this.hasPermission = permission === 'granted';
            } catch (error) {
              console.warn('IMU permission denied:', error);
              this.hasPermission = false;
            }
          } else {
            this.hasPermission = true;
          }

          if (this.hasPermission) {
            window.addEventListener('devicemotion', (e) => {
              if (e.accelerationIncludingGravity) {
                this.acceleration = {
                  x: e.accelerationIncludingGravity.x || 0,
                  y: e.accelerationIncludingGravity.y || 0,
                  z: e.accelerationIncludingGravity.z || 0
                };
              }
            });

            window.addEventListener('deviceorientation', (e) => {
              this.rotation = {
                alpha: e.alpha || 0,
                beta: e.beta || 0,
                gamma: e.gamma || 0
              };
            });
          }

          this.initialized = true;
          return this.hasPermission;
        }

        getStabilityScore() {
          // Calculate how stable the device is (0-1, higher = more stable)
          const accMagnitude = Math.sqrt(
            this.acceleration.x ** 2 + 
            this.acceleration.y ** 2 + 
            this.acceleration.z ** 2
          );
          // If close to gravity (9.8), device is stable
          const stability = Math.max(0, 1 - Math.abs(accMagnitude - 9.8) / 5);
          return stability;
        }
      }

      // ============================================
      // ADVANCED STABILIZER COMPONENT
      // ============================================
      AFRAME.registerComponent('ar-stabilizer', {
        schema: {
          smoothing: { type: 'number', default: 0.15 },  // Lower = smoother but more lag
          minConfidence: { type: 'number', default: 0.3 },  // Minimum tracking confidence
          useKalman: { type: 'boolean', default: true },
          useIMU: { type: 'boolean', default: true },
          adaptive: { type: 'boolean', default: true }  // Adapt smoothing based on motion
        },

        init: function() {
          this.targetEntity = this.el;
          this.isTracking = false;
          this.lastValidPose = {
            position: new THREE.Vector3(),
            rotation: new THREE.Quaternion(),
            scale: new THREE.Vector3(1, 1, 1)
          };
          
          // Kalman filters for position and rotation
          this.positionKalman = new VectorKalmanFilter(0.01, 0.15);
          this.rotationKalman = new VectorKalmanFilter(0.01, 0.2);
          
          // IMU reader
          this.imu = new IMUReader();
          if (this.data.useIMU) {
            this.imu.init().then(success => {
              if (success) console.log('IMU stabilization enabled');
            });
          }

          // Smoothed values
          this.smoothPosition = new THREE.Vector3();
          this.smoothRotation = new THREE.Quaternion();
          this.smoothEuler = new THREE.Euler();
          
          // Velocity tracking for prediction
          this.velocity = new THREE.Vector3();
          this.lastPosition = new THREE.Vector3();
          this.lastTime = performance.now();

          // Lost tracking timeout
          this.lostTrackingTime = 0;
          this.maxLostTime = 500; // ms

          // Bind to MindAR events
          this.targetEntity.addEventListener('targetFound', () => {
            this.isTracking = true;
            this.lostTrackingTime = 0;
          });

          this.targetEntity.addEventListener('targetLost', () => {
            this.isTracking = false;
            this.lostTrackingTime = performance.now();
          });
        },

        tick: function(time, deltaTime) {
          if (!this.targetEntity.object3D) return;

          const obj3D = this.targetEntity.object3D;
          
          if (this.isTracking) {
            // Get raw tracked position
            const rawPos = obj3D.position.clone();
            const rawRot = obj3D.quaternion.clone();
            
            // Calculate velocity for prediction
            const currentTime = performance.now();
            const dt = (currentTime - this.lastTime) / 1000;
            this.velocity.copy(rawPos).sub(this.lastPosition).divideScalar(dt);
            this.lastPosition.copy(rawPos);
            this.lastTime = currentTime;

            // Apply Kalman filtering
            let filteredPos = rawPos;
            if (this.data.useKalman) {
              const kalmanResult = this.positionKalman.filter(rawPos);
              filteredPos = new THREE.Vector3(kalmanResult.x, kalmanResult.y, kalmanResult.z);
            }

            // Adaptive smoothing based on IMU stability
            let smoothingFactor = this.data.smoothing;
            if (this.data.adaptive && this.imu.hasPermission) {
              const stability = this.imu.getStabilityScore();
              // More stable = more smoothing
              smoothingFactor = this.data.smoothing * (0.5 + stability * 0.5);
            }

            // Exponential smoothing (lerp)
            this.smoothPosition.lerp(filteredPos, smoothingFactor);
            this.smoothRotation.slerp(rawRot, smoothingFactor);

            // Apply smoothed transform
            obj3D.position.copy(this.smoothPosition);
            obj3D.quaternion.copy(this.smoothRotation);

            // Save last valid pose
            this.lastValidPose.position.copy(this.smoothPosition);
            this.lastValidPose.rotation.copy(this.smoothRotation);
            
          } else {
            // Lost tracking - use prediction
            const timeLost = performance.now() - this.lostTrackingTime;
            
            if (timeLost < this.maxLostTime && this.velocity.length() > 0.001) {
              // Predict position using velocity
              const predictedPos = this.lastValidPose.position.clone()
                .add(this.velocity.clone().multiplyScalar(timeLost / 1000));
              
              obj3D.position.copy(predictedPos);
              obj3D.quaternion.copy(this.lastValidPose.rotation);
            } else {
              // Hold last known good position
              obj3D.position.copy(this.lastValidPose.position);
              obj3D.quaternion.copy(this.lastValidPose.rotation);
            }
          }
        }
      });

      // ============================================
      // CONFIDENCE-BASED VISIBILITY
      // ============================================
      AFRAME.registerComponent('confidence-visibility', {
        schema: {
          fadeTime: { type: 'number', default: 200 }  // ms
        },

        init: function() {
          this.visible = false;
          this.opacity = 0;
          this.fadeStartTime = 0;
          this.isFading = false;

          // Get all mesh materials for opacity control
          this.materials = [];
          this.el.object3D.traverse((node) => {
            if (node.material) {
              this.materials.push(node.material);
              node.material.transparent = true;
            }
          });

          this.el.addEventListener('targetFound', () => {
            this.visible = true;
            this.fadeStartTime = performance.now();
            this.isFading = true;
          });

          this.el.addEventListener('targetLost', () => {
            this.visible = false;
            this.fadeStartTime = performance.now();
            this.isFading = true;
          });
        },

        tick: function(time) {
          if (!this.isFading) return;

          const elapsed = performance.now() - this.fadeStartTime;
          const progress = Math.min(elapsed / this.data.fadeTime, 1);

          if (this.visible) {
            this.opacity = progress;
          } else {
            this.opacity = 1 - progress;
          }

          // Apply opacity to all materials
          this.materials.forEach(mat => {
            mat.opacity = this.opacity;
          });

          if (progress >= 1) {
            this.isFading = false;
          }
        }
      });

      // ============================================
      // PHYSICS-BASED DAMPING (OPTIONAL)
      // ============================================
      AFRAME.registerComponent('spring-follow', {
        schema: {
          stiffness: { type: 'number', default: 100 },
          damping: { type: 'number', default: 10 }
        },

        init: function() {
          this.velocity = new THREE.Vector3();
          this.target = new THREE.Vector3();
        },

        tick: function(time, deltaTime) {
          const dt = deltaTime / 1000;
          const pos = this.el.object3D.position;
          
          // Spring force: F = -k * x - c * v
          const displacement = this.target.clone().sub(pos);
          const force = displacement.multiplyScalar(this.data.stiffness)
            .sub(this.velocity.clone().multiplyScalar(this.data.damping));
          
          this.velocity.add(force.multiplyScalar(dt));
          pos.add(this.velocity.clone().multiplyScalar(dt));
        },

        setTarget: function(position) {
          this.target.copy(position);
        }
      });

    </script>
  </head>
  <body>
    <a-scene 
      mindar-image="imageTargetSrc: https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.2.5/examples/image-tracking/assets/band-example/band.mind; filterMinCF: 0.0001; filterBeta: 0.01;" 
      color-space="sRGB" 
      renderer="colorManagement: true, physicallyCorrectLights" 
      vr-mode-ui="enabled: false" 
      device-orientation-permission-ui="enabled: false">
      
      <a-assets>
        <a-asset-item id="bearModel" src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.2.5/examples/image-tracking/assets/band-example/bear/scene.gltf"></a-asset-item>
        <a-asset-item id="raccoonModel" src="https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.2.5/examples/image-tracking/assets/band-example/raccoon/scene.gltf"></a-asset-item>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- RACCOON with FULL STABILIZATION -->
      <a-entity 
        mindar-image-target="targetIndex: 0"
        ar-stabilizer="smoothing: 0.15; minConfidence: 0.3; useKalman: true; useIMU: true; adaptive: true">
        <a-gltf-model 
          rotation="0 0 0" 
          position="0 -0.25 0" 
          scale="0.05 0.05 0.05" 
          src="#raccoonModel" 
          animation-mixer
          confidence-visibility="fadeTime: 200">
        </a-gltf-model>
      </a-entity>

      <!-- BEAR with FULL STABILIZATION -->
      <a-entity 
        mindar-image-target="targetIndex: 1"
        ar-stabilizer="smoothing: 0.15; minConfidence: 0.3; useKalman: true; useIMU: true; adaptive: true">
        <a-gltf-model 
          rotation="0 0 0" 
          position="0 -0.25 0" 
          scale="0.05 0.05 0.05" 
          src="#bearModel" 
          animation-mixer
          confidence-visibility="fadeTime: 200">
        </a-gltf-model>
      </a-entity>
    </a-scene>

    <div style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; font-family: monospace; font-size: 12px; border-radius: 5px; z-index: 1000;">
      <div>ðŸŽ¯ AR Stabilization Active</div>
      <div>âœ“ Kalman Filtering</div>
      <div>âœ“ IMU Fusion</div>
      <div>âœ“ Adaptive Smoothing</div>
      <div>âœ“ Motion Prediction</div>
    </div>
  </body>
</html>